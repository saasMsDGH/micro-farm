name: üèó Build & Deploy Service

on:
  push:
    tags:
      - '*@v*' # Format attendu : service/v1.2.3

jobs:
  # STEP 1 : ANALYSE DU TAG
  parse-tag:
    runs-on: ubuntu-latest
    outputs:
      service: ${{ steps.extract.outputs.service }}
      version: ${{ steps.extract.outputs.version }}
    steps:
      - id: extract
        run: |
          # Extraction du nom du service et de la version depuis le tag
          # Exemple : youtube-dl/v1.0.4 -> service=youtube-dl, version=1.0.4
          TAG=${{ github.ref_name }}
          echo "service=${TAG%%@*}" >> $GITHUB_OUTPUT
          echo "version=${TAG##*v}" >> $GITHUB_OUTPUT

  # STEP 2 : BUILD & TEST
  build-test:
    needs: parse-tag
    runs-on: ubuntu-latest
    outputs:
      service: ${{ steps.extract.outputs.service }}
      version: ${{ steps.extract.outputs.version }}
    steps:
      - id: extract
        run: |
          TAG=${{ github.ref_name }}
          # On coupe avant le @ pour avoir le nom du dossier (ex: youtube-dl)
          echo "service=${TAG%@*}" >> $GITHUB_OUTPUT
          # On coupe apr√É¬®s le v pour avoir la version (ex: 0.1.1)
          echo "version=${TAG##*v}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      
      # Test du code Go avant le build
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'
      
      - name: Run Go Tests
        run: cd services/${{ needs.parse-tag.outputs.service }} && go test -v ./...

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Construction de l'image Docker
      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          build-args: SERVICE_NAME=${{ needs.parse-tag.outputs.service }}
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ needs.parse-tag.outputs.service }}:${{ needs.parse-tag.outputs.version }}
            ${{ secrets.DOCKER_USERNAME }}/${{ needs.parse-tag.outputs.service }}:latest

  # STEP 3 : DEPLOYMENT
  deploy:
    needs: [parse-tag, build-test]
    runs-on: [self-hosted, k8s-deploy] # Ton runner connect√© √† ton cluster OVH
    steps:
      - uses: actions/checkout@v4 # Crucial pour avoir acc√®s aux fichiers YAML
      - name: Deploy to Kubernetes
        run: |
          SERVICE="${{ needs.parse-tag.outputs.service }}"
          VERSION="${{ needs.parse-tag.outputs.version }}"
          IMAGE="${{ secrets.DOCKER_USERNAME }}/$SERVICE:$VERSION"
          
          echo "üöÄ Pr√©paration du d√©ploiement pour $SERVICE (image: $IMAGE)"
          
          # 1. Injection de l'image dans le Deployment
          sed -i "s|image: .*|image: $IMAGE|g" k8s/$SERVICE/deployment.yaml

          # 2. Injection du Secret YouTube depuis GitHub Secrets
          # On remplace le placeholder par la valeur du secret GitHub
          sed -i "s|cookies.txt: .*|cookies.txt: ${{ secrets.YOUTUBE_COOKIES_BASE64 }}|g" k8s/$SERVICE/secret.yaml

          # 3. Application de la configuration compl√®te (incluant le nouveau secret)
          kubectl apply -f k8s/$SERVICE/ -n apps

          # 4. V√©rification du d√©ploiement
          kubectl rollout status deployment/$SERVICE -n apps