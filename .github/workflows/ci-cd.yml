name: üöÄ Monorepo CI/CD

on:
  push:
    branches: ["main"]
    paths:
      - 'services/**' # D√©clenchement uniquement si un service change
      - 'pkg/**'      # Ou le code partag√©
      - 'Dockerfile'  # Ou le constructeur

jobs:
  # JOB 1: D√âTECTION DES CHANGEMENTS
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Identify changed services
        id: set-matrix
        run: |
          # D√©tecte les dossiers modifi√©s dans services/
          CHANGES=$(git diff --name-only HEAD^ HEAD | grep '^services/' | cut -d/ -f2 | sort -u | jq -R . | jq -s -c .)
          
          # Si pkg/ ou Dockerfile change, on consid√®re que TOUS les services doivent √™tre rebuild√©s
          GLOBAL_CHANGE=$(git diff --name-only HEAD^ HEAD | grep -E '^(pkg/|Dockerfile)')
          if [ ! -z "$GLOBAL_CHANGE" ]; then
             echo "‚ö†Ô∏è Changement global d√©tect√© (pkg ou Dockerfile), rebuild complet."
             CHANGES=$(ls services | jq -R . | jq -s -c .)
          fi

          # Si rien n'a chang√© (cas rare), on renvoie un tableau vide
          if [ -z "$CHANGES" ]; then CHANGES="[]"; fi
          
          echo "Services √† mettre √† jour: $CHANGES"
          echo "matrix=$CHANGES" >> $GITHUB_OUTPUT

  # JOB 2: BUILD & PUSH (Docker Hub)
  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.matrix != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          build-args: |
            SERVICE_NAME=${{ matrix.service }}
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:latest
            ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }}

  # JOB 3: DEPLOY (Sur ton Cluster via Runner Self-Hosted)
  deploy:
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.matrix != '[]'
    runs-on: [self-hosted, k8s-deploy] # Ton runner perso
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    
    steps:
      - name: Checkout Manifests
        uses: actions/checkout@v4

      - name: Deploy ${{ matrix.service }} to K8s
        run: |
          SERVICE="${{ matrix.service }}"
          IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }}"
          NAMESPACE="apps"
          
          echo "üöÄ D√©ploiement de $SERVICE avec l'image $IMAGE..."
          
          # 1. Appliquer la config K8s (Ingress, Service, Deployment)
          # Le dossier doit exister: k8s/youtube-dl/*.yaml
          if [ -d "k8s/$SERVICE" ]; then
            kubectl apply -f k8s/$SERVICE/ -n $NAMESPACE
            
            # 2. Forcer la mise √† jour de l'image (Rolling Update)
            kubectl set image deployment/$SERVICE $SERVICE=$IMAGE -n $NAMESPACE
            
            # 3. V√©rification du d√©ploiement
            kubectl rollout status deployment/$SERVICE -n $NAMESPACE
            echo "‚úÖ $SERVICE d√©ploy√© avec succ√®s !"
          else
            echo "‚ö†Ô∏è Pas de configuration K8s trouv√©e dans k8s/$SERVICE, saut du d√©ploiement."
          fi